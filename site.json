{"title":"R.apex","githubRepo":"Click-to-Cloud/R.apex","googleAnalytics":"","index":{"title":"Home","description":"R.apex is a functional library based on Apex, inspired by Lodash and Ramda.js.","content":" Fluent API R.apex honors the style of function call chaining, which greatly improves usability and code readability. Collection Support R.apex has various functions available to support collection manipulations. Function Composition R.apex provides a rich set of tools to help you compose functions to reuse your code. ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/r-apex/./","children":{"docs":{"title":"Docs","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/r-apex/docs/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/r-apex/docs/search.html"},"R_Funcs":{"children":{"arithmetic":{"title":"Arithmetic Funcs","description":"Arithmetic Funcs in R","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} add Add two numbers. R.add.run(1, 2) // 3 dec Decrement the number. R.dec.run(1) // 0 divide Divide two numbers. R.divide.run(1, 2) // 0.5 inc Increment the number. R.inc.run(1) // 2 mod Calculate the modulo. R.mod.run(1, 2) // 1 multiply Multiply two numbers. R.multiply.run(1, 2) // 2 negate Negate the number. R.negate.run(1) // -1 product Multiply all the numbers. R.product.run(1, 2, 3) // 6 subtract Subtract one number from another. R.subtract.run(1, 2) // -1 ","srcFilePath":"src/pages/docs/R_Funcs/arithmetic.md","id":"arithmetic","location":"/docs/R_Funcs/arithmetic.html","url":"/r-apex/docs/R_Funcs/arithmetic.html"},"comparator":{"title":"Comparator Funcs","description":"Comparator Funcs in R","layout":"guide","icon":"code-file","weight":6,"content":" {$page.description} ascend Convert a function into an ascending comparator. Func f = (Func)R.ascend.run(R.identity); System.debug(f.run(1, 2)); // -1 cascade Combine the comparator functions into one. Func f = (Func)R.cascade.run( (Func)R.ascend.run(R.prop.apply('FirstName')), (Func)R.ascend.run(R.prop.apply('Description')) ); clamp Limit the value between the min and the max. R.clamp.run(1, 3, 5) // 3 comparator Convert a Boolean-returning comparator to an Integer-returning comparator. Func f = (Func)R.comparator.run(R.lt); System.debug(f.run(1, 2)); // -1 compare Compare two objects. R.compare.run(1, 2) // -1 descend Convert a function into an descending comparator. Func f = (Func)R.descend.run(R.identity); System.debug(f.run(1, 2)); // 1 ","srcFilePath":"src/pages/docs/R_Funcs/comparator.md","id":"comparator","location":"/docs/R_Funcs/comparator.html","url":"/r-apex/docs/R_Funcs/comparator.html"},"condition":{"title":"Condition Funcs","description":"Condition Funcs in R","layout":"guide","icon":"code-file","weight":7,"content":" {$page.description} cond Returns a function, fn, which encapsulates if/else, if/else, logic. It takes a list of functions, alternated by predicate and transformer. All of the arguments to fn are applied to each of the predicates in turn until one returns a \"truthy\" value, at which point fn returns the result of applying its arguments to the corresponding transformer. Func testF = (Func)R.cond.runN(new List{ R.lt.apply(0), R.always.run(1), R.gt.apply(0), R.always.run(-1), R.equals.apply(0), R.always.run(0) }); testF.run(3); // 1 doWhen Tests the final argument by passing it to the given predicate function. If the predicate is satisfied, the function will return the result of calling the whenTrueFn function with the same argument. If the predicate is not satisfied, the argument is returned as a wrapping list. Func testF = (Func)R.doWhen.run( R.lt.apply(0), R.always.run(1) ); testF.run(3); // 1 ifElse Creates a function that will process either the onTrue or the onFalse function depending upon the result of the condition predicate. Func testF = (Func)R.ifElse.run( R.lt.apply(0), R.always.run(1), R.always.run(0) ); testF.run(3); // 1 unless Tests the final argument by passing it to the given predicate function. If the predicate is not satisfied, the function will return the result of calling the whenFalseFn function with the same argument. If the predicate is satisfied, the argument is returned as a wrapping list. Func testF = (Func)R.unless.run( R.lt.apply(0), R.always.run(0) ); testF.run(-3); // 0 ","srcFilePath":"src/pages/docs/R_Funcs/condition.md","id":"condition","location":"/docs/R_Funcs/condition.html","url":"/r-apex/docs/R_Funcs/condition.html"},"conversion":{"title":"Conversion Funcs","description":"Conversion Funcs in R","layout":"guide","icon":"code-file","weight":1,"content":" {$page.description} Single Value Conversion Convert single values. Examples are like: Object a = ...; String str = (String)R.toString.run(a); | Type | Func | | ---- | ---- | | Boolean | toBoolean | | Integer | toInteger | | Long | toLong | | Double | toDouble | | Decimal | toDecimal | | String | toString | | Date | toDate | | Time | toTime | | Datetime | toDatetime | | Func | toFunc | | R.Pair | toPair | | SObject | toSObject | List Value Conversion Convert list values. Examples are like: Object a = ...; List strList = (List)R.toStringList.run(a); | Type | Func | | ---- | ---- | | List&lt;Object&gt; | toList | | List&lt;Boolean&gt; | toBooleanList | | List&lt;Integer&gt; | toIntegerList | | List&lt;Long&gt; | toLongList | | List&lt;Double&gt; | toDoubleList | | List&lt;Decimal&gt; | toDecimalList | | List&lt;String&gt; | toStringList | | List&lt;Date&gt; | toDateList | | List&lt;Time&gt; | toTimeList | | List&lt;Datetime&gt; | toDatetimeList | | List&lt;Func&gt; | toFuncList | | List&lt;R.Pair&gt; | toPairList | | List&lt;SObject&gt; | toSObjectList | Map Value Conversion Convert map values. Examples are like: Object a = ...; Map strMap = (Map)R.toStringMap.run(a); | Type | Func | | ---- | ---- | | Map&lt;String, Object&gt; | toMap | | Map&lt;String, Boolean&gt; | toBooleanMap | | Map&lt;String, Integer&gt; | toIntegerMap | | Map&lt;String, Long&gt; | toLongMap | | Map&lt;String, Double&gt; | toDoubleMap | | Map&lt;String, Decimal&gt; | toDecimalMap | | Map&lt;String, String&gt; | toStringMap | | Map&lt;String, Date&gt; | toDateMap | | Map&lt;String, Time&gt; | toTimeMap | | Map&lt;String, Datetime&gt; | toDatetimeMap | | Map&lt;String, Func&gt; | toFuncMap | | Map&lt;String, R.Pair&gt; | toPairMap | | Map&lt;String, SObject&gt; | toSObjectMap | Set Value Conversion Convert set values. Examples are like: Object a = ...; Set strSet =(Set)R.toSet.run(a); Set strSet = (Set)R.toIdSet.run(a); | Type | Func | | ---- | ---- | | Set&lt;String&gt; | toSet | | Set&lt;Id&gt; | toIdSet | Conversion Check Check if conversions can be made. Examples are like: Object a = ...; Boolean b = (Boolean)R.isStringLike.run(a); | Type | Func | | ---- | ---- | | String | isStringLike | | Func | isFuncLike | | List&lt;Object&gt; | isListLike | | Set&lt;String&gt; | isSetLike | | Map&lt;String, Object&gt; | isMapLike | | R.Pair | isPairLike | | SObject | isSObjectLike | ","srcFilePath":"src/pages/docs/R_Funcs/conversion.md","id":"conversion","location":"/docs/R_Funcs/conversion.html","url":"/r-apex/docs/R_Funcs/conversion.html"},"database":{"title":"Database Funcs","description":"Database Funcs in R","layout":"guide","icon":"code-file","weight":12,"content":" {$page.description} dbInsert Insert SObject(s) into database Account acc = ...; R.dbInsert.run(acc); dbUpdate Update SObject(s) into database Account acc = ...; R.dbUpdate.run(acc); dbDelete Delete SObject(s) from database Account acc = ...; R.dbDelete.run(acc); dbQuery Query SObject(s) from database String query = '...': R.dbQuery.run(query); ","srcFilePath":"src/pages/docs/R_Funcs/database.md","id":"database","location":"/docs/R_Funcs/database.html","url":"/r-apex/docs/R_Funcs/database.html"},"function":{"title":"Function Funcs","description":"Function Funcs in R","layout":"guide","icon":"code-file","weight":5,"content":" {$page.description} always Return a function which returns the value whenever called. Func f = (Func)R.always.run(1); System.debug(f.run(2)); applySpec Given a spec object recursively mapping properties to functions, creates a function producing an object of the same structure, by mapping each property to the result of calling its associated function with the supplied arguments. Map spec = new Map{ 'add' = R.add, 'subtract' = R.subtract }; System.debug(R.applySpec.run(spec, 1, 2)); // {add=3, subtract=-1} binary Make the function accept only two arguments. See nAry. compose Compose the functions in a composing style. Composed functions are executed from right to left. Func f = (Func)R.pipe.run( R.add.apply(1), R.multiply.apply(2) ); System.debug(f.run(1)); // 3 converge Accepts a converging function and branching functions and returns a new function. When invoked, this new function is applied to some arguments, each branching function is applied to those same arguments. The results of each branching function are passed as arguments to the converging function to produce the return value. Func f = (Func)R.converge.run( R.multiply, R.add, R.subtract ); System.debug(f.run(1, 2)); // -3 evlove Creates a new object by recursively evolving a copy of object, according to the transformation functions. R.evolve.run(new Map{ 'name' = R.append.apply('$') }, new Map{ 'name' = 'test' }) // {name=test$} flip Flip the first two arguments of a function. Func f = (Func)R.flip.run(R.subtract); System.debug(f.run(1, 2)); // 1 identity Return whatever is passed in. R.identity.run('abc') // abc juxt Applies a list of functions to a list of values. List fns = new List{ R.add, R.subtract }; System.debug(R.juxt.run(fns, 1, 2)); // (3, -1) memoize Wrap the function to make it memoizable. Func testF = (Func)R.memoize.run( R.add.apply(1), 'testF', R.toString ); nAry Wrap the function to make it accept only N arguments. Func f = (Func)R.nAry.run(2, R.product); System.debug(f.run(1, 2, 3)); // 2 once Wrap the function to make it call only by once. Func testF = (Func)R.once.run(R.add.apply(1), 'testF'); testF.run(1) // 2 testF.run(2) // 2 pipe Compose the functions in a piping style. Composed functions are executed from left to right. Func f = (Func)R.pipe.run( R.add.apply(1), R.multiply.apply(2) ); System.debug(f.run(1)); // 4 placeholder A placeholder in the applied arguments. R.subtract.apply(R.placeholder, 2).run(1) // -1 transform Apply the function to the target. R.transform.run(R.inc, 1) // 2 unary Make the function accept only one argument. See nAry. useWith Accepts a function fn and other functions and returns a new function. When the new function is invoked, it calls the function fn with parameters consisting of the result of calling each supplied handler on successive arguments to the new function. Func f = (Func)R.useWith.run( R.multiply, R.add.apply(1), R.subtract.apply(1) ); System.debug(f.run(1, 2)); // -2 constant Return a function which returns the value whenever called. Func f = R.constant.apply(2); System.debug(f.run(2)); throwException Throws exception R.throwException.run(new Func.FuncException('test')); ","srcFilePath":"src/pages/docs/R_Funcs/function.md","id":"function","location":"/docs/R_Funcs/function.html","url":"/r-apex/docs/R_Funcs/function.html"},"list":{"title":"List Funcs","description":"List Funcs in R","layout":"guide","icon":"code-file","weight":8,"content":" {$page.description} adjust Adjust the element using the function. R.adjust.run(R.inc, 1, R.with(1, 2, 3)) // (1, 3, 3) all Check if all elements match the predicate. R.all.run(R.isNotNull, R.with(1, 2, 3)) // true append Append an element to the elements. R.append.run(1, R.with(1, 2, 3)) // (1, 2, 3, 1) assoc Set the key value. R.assoc.run('name', 'test', new Map()) // {name=test} biMap Map over both the keys and values. R.bimap.run(R.append.apply('key'), R.append.apply('value'), R.withObj('name', 'test')) // {testkey=testvalue} concat Concatenate two objects. R.concat.run(R.with(1, 2, 3), R.with(4, 5, 6)) // (4, 5, 6, 1, 2, 3) contains Check if the element is contained. R.contains.run(1, R.with(1, 2, 3)) // true containsBy Check if the element is contained by the comparator returning boolean. R.containsBy.run(R.equals, 1, R.with(1, 2, 3)) // true containsKey Check if the key is contained. R.containsKey.run('name', new Map{ 'name' = 'test' }) // true countBy Get counts by the key. R.countBy.run(R.identity, R.with(1, 2, 2)) // {1=1, 2=2} difference Make a difference of the two objects. R.difference.run(R.with(1, 2, 3), R.with(2, 3, 4)) // (4) dissoc Remove the key value. R.dissoc.run('name', new Map{ 'name' = 'test' }) // {} doInsert Insert element at the index. R.doInsert.run(1, 'x', R.with(1, 2, 3)) // (1, x, 2, 3) doInsertAll Insert elements at the index. R.doInsertAll.run(1, R.with('x', 'y'), R.with(1, 2, 3)) // (1, x, y, 2, 3) doJoin Join the elements by the separator. R.doJoin.run('-', R.with(1, 2, 3)) // 1-2-3 doMap Map over the elements. R.doMap.run(R.inc, R.with(1, 2, 3)) // (2, 3, 4) doUpdate Update an element of the elements. R.doUpdate.run(1, 3, R.with(1, 2, 3)) // (1, 3, 3) drop Drop first N elements. R.drop.run(1, 'abc') // bc dropRight Drop first N elements from right. R.dropRight.run(1, 'abc') // ab dropRightWhile Drop elements from right until not satisfied. R.dropRightWhile.run(R.equals.apply('a'), 'abc') // abc dropWhile Drop elements until not satisfied. R.dropWhile.run(R.equals.apply('a'), 'abc') // bc endsWith Check ending with. R.endsWith('a', 'abc') // false every Same as all. filter Filter on the elements. R.filter.run(R.isNotNull, R.with('a', null, 'b')) // (a, b) find Find the first element that matches the predicate. R.find.run(R.equals.apply('a'), R.with('a', 'b')) // a findIndex Find the index of the first element that matches the predicate. R.findIndex.run(R.equals.apply('a'), R.with('a', 'b')) // 0 findLast Find the first element from last that matches the predicate. R.findLast.run(R.equals.apply('a'), R.with('a', 'b')) // a findlastIndex Find the index of the first element from last that matches the predicate. R.findLastIndex.run(R.equals.apply('a'), R.with('a', 'b')) // 0 first Get the first element. R.first.run(R.with(1, 2, 3)) // 1 flatten Flatten the elements recursively. R.flatten.run(R.with(1, R.with(2, R.with(3)))) // (1, 2, 3) forEach Do for-each on the elements. R.forEach.run(R.debug, R.with(1, 2, 3)); // 1 // 2 // 3 fromPairs Convert a list of pairs to map. R.fromPairs.run(R.with(new R.Pair('a', 1))) // {a=1} groupBy Get groups by the key. R.groupBy.run(R.identity, R.with(1, 2, 2)) // {1=(1), 2=(2, 2)} head Same as first. indexBy Get indexes by the key. R.indexBy.run(R.identity, R.with(1, 2, 2)) // {1=1, 2=2} indexOf Get the index of the first element found. R.indexOf.run(1, R.with(1, 2, 3)) // 0 init Get the elements except the last. R.init.run(R.with(1, 2, 3)) // (1, 2) intersection Make an intersection of the two objects. R.intersection.run(R.with(1, 2, 3), R.with(2, 3, 4)) // (2, 3) isEmpty Check if it is empty. R.isEmpty.run(R.with(1, 2, 3)) // false last Get the last element. R.last.run(R.with(1, 2, 3)) // 3 lastIndexOf Get the index of the first element found from the last. R.lastIndexOf.run(1, R.with(1, 2, 3)) // 0 length Get the length. R.length.run(R.with(1, 2, 3)) // 3 none Check if none of the elements match the predicate. R.none.run(R.isNotNull, R.with(1, 2, 3)) // true nth Get the nth element. R.nth.run(1, R.with(1, 2, 3)) // 2 pair Create a pair. R.pair.run(1, 2) // Pair:[fst=1, snd=2] partition Create a partitioned pair using the predicate. R.partition.run(R.equals.apply('a'), R.with('a', 'b', 'c')) // Pair:[fst=(a), snd=(b, c)] pluck Pluck the fields out of elements. R.pluck.run('Description', R.with(new Account(Description='desc'))) // (desc) prepend Prepend an element to the elements. R.prepend.run(1, R.with(1, 2, 3)) // (1, 1, 2, 3) project Project elements into other elements according to the fields. R.project.run(R.with('Description'), R.with(new Account(Description='desc'))) // ({Description=desc}) range Generate a range of decimals. R.range.run(1, 3) // (1, 2) reduce Reduce over the elements. R.reduce.run(R.add, 0, R.with(1, 2, 3)) // 6 reject Reject on the elements. R.reject.run(R.isNull, R.with('a', null, 'b')) // (a, b) remove Remove elements. R.remove.run(1, 2, R.with(1, 2, 3)) // (1) repeat Repeat the target to generate elements. R.repeat.run(5, 'a') // (a, a, a, a, a) reverse Reverse the elements. R.reverse.run('abc') // cba sample Get a random element. R.sample.run('abcdef') // e sampleSize Get a list of random elements. R.sampleSize.run(2, 'abcdef') // df shuffle Create a shuffled collection. R.shuffle.run('abcdef') // fdeabc size Get the size. See length. slice Get a slice of the elements. R.slice.run(0, 1, R.with(1, 2, 3)) // (1) some Check if some elements match the predicate. R.some.run(R.isNotNull, R.with(1, 2, 3)) // false sortBy Sort by the comparator. R.sortBy.run(R.compare, R.with(3, 2, 1)) // (1, 2, 3) sortDefault Sort by default. R.sortDefault.run(R.with(3, 2, 1)) // (1, 2, 3) startsWith Check starting with. R.startsWith('a', 'abc') // true sum Get the sum. R.sum.run(R.with(1, 2, 3)) // 6 tail Get the elements except the first. R.tail.run(R.with(1, 2, 3)) // (2, 3) take Take the first N elements. R.take.run(1, 'abc') // a takeRight Take the first N elements from right. R.takeRight.run(1, 'abc') // c takeRightWhile Take elements from right until not satisfied. R.takeRightWhile.run(R.equals.apply('a'), 'abc') // takeWhile Take elements until not satisfied. R.takeWhile.run(R.equals.apply('a'), 'abc') // a times Invoke a function for N times. R.times.run(3, R.identity) // (0, 1, 2) toPairs Convert a map to a list of pairs. R.toPairs.run(new Map{ 'name' = 'test' }) // (Pair:[fst=name, snd=test]) union Make a union of the two objects. R.union.run(R.with(1, 2, 3), R.with(2, 3, 4)) // (2, 3, 4, 1) uniq Get a unique collection of the elements. R.uniq.run(R.with(1, 2, 2)) // (1, 2) unnest Flatten the elements by one level. R.unnest.run(R.with(1, R.with(2, 3))) // (1, 2, 3) without Same with difference. xor Make an xor of the two objects. R.xor.run(R.with(1, 2, 3), R.with(2, 3, 4)) // (4, 1) zip Zip two collections to create a list of pairs. R.zip.run(R.with('a', 'b'), R.with(1, 2)) // (Pair:[fst=a, snd=1], Pair:[fst=b, snd=2]) zipObj Zip two collections to create a map. R.zipObj.run(R.with('a', 'b'), R.with(1, 2)) // {a=1, b=2} ","srcFilePath":"src/pages/docs/R_Funcs/list.md","id":"list","location":"/docs/R_Funcs/list.html","url":"/r-apex/docs/R_Funcs/list.html"},"logic":{"title":"Logic Funcs","description":"Logic Funcs in R","layout":"guide","icon":"code-file","weight":3,"content":" {$page.description} allPass Create a function that combines all predicates with 'and'. Func f = (Func)R.allPass.run( R.startsWith.apply('c'), R.endsWith.apply('t') ); system.debug(f.run('cat')); // true anyPass Create a function that combines all predicates with 'or'. Func f = (Func)R.anyPass.run( R.startsWith.apply('c'), R.endsWith.apply('t') ); system.debug(f.run('cc')); // true complement Create a function that negate the predicate. Func f = (Func)R.complement.run(R.equals.apply('cat')); system.debug(f.run('cat')); // false doAnd Test logic 'and'. R.doAnd.run(true, false) // false doNot Test logic 'not'. R.doNot.run(false) // true doOr Test logic 'or'. R.doOr.run(true, false) // true ","srcFilePath":"src/pages/docs/R_Funcs/logic.md","id":"logic","location":"/docs/R_Funcs/logic.html","url":"/r-apex/docs/R_Funcs/logic.html"},"map":{"title":"Map Funcs","description":"Map Funcs in R","layout":"guide","icon":"code-file","weight":10,"content":" {$page.description} doMerge Merge the two objects. R.doMerge.run(R.withObj('name', 'b'), R.withObj('name', 'a')) // {name=b} has Check if the wrapped object has a non-null value of the field. R.has.run('Description', new Account()) // false invert Invert the wrapped object, with values mapped by the same key added to a list. R.invert.run(R.withObj('name', 'test')) // {name=test} invertObj Invert the wrapped object. R.invertObj.run(R.withObj('name', 'test')) // {name=test} keys Get the keys. R.keys.run(R.withObj('name', 'test')) // {name} omit Omit the fields and pick remaining fields into a map. R.omit.run(R.with('Description'), new Account(Description='desc', FirstName='name')) // {FirstName=name} pick Pick the fields into a map. R.pick.run(R.with('Description'), new Account(Description='desc', FirstName='name')) // {Description=desc} prop Get the property value. R.prop.run('Description', new Account(Description='desc')) // desc propEq Check that its property value equals given value. R.propEq.run('Description', 'desc', new Account(Description='desc')) // true propOr Get the property value, or return the default value if it is null. R.propOr.run('Description', 'desc', new Account()) // desc propSObject Get the property value by 'getSObject'. propSObjects Get the property value by 'getSObjects'. propSatisfies Check if the property value satisfies the predicate. R.propSatisfies.run('Description', R.isNotNull, new Account()) // false values Get the values. R.values.run(R.withObj('name', 'test')) // (test) whereEq Check if matching the key-values. R.whereEq.run(R.withObj('Description', 'desc'), new Account(Description='desc')) // true whereSatisfies Check if matching the key-predicates. R.whereSatisfies.run(R.withObj('Description', R.isNotNull), new Account(Description='desc')) // true path Get the property value according to the field path, separated by '.'. R.path.run('Owner.Id', acc) // desc ","srcFilePath":"src/pages/docs/R_Funcs/map.md","id":"map","location":"/docs/R_Funcs/map.html","url":"/r-apex/docs/R_Funcs/map.html"},"relation":{"title":"Relation Funcs","description":"Relation Funcs in R","layout":"guide","icon":"code-file","weight":4,"content":" {$page.description} equals Check if two values are equal. R.equals.run(1, 1) // true gt Check for 'greater than'. R.gt.run(3, 2) // true gte Check for 'greater than or equal'. R.gte.run(3, 2) // true lt Check for 'less than'. R.lt.run(1, 2) // true lte Check for 'less than or equal'. R.lte.run(1, 2) // true max Check for the max value between the two. R.max.run(1, 2) // 2 min Check for the min value between the two. R.min.run(1, 2) // 1 ","srcFilePath":"src/pages/docs/R_Funcs/relation.md","id":"relation","location":"/docs/R_Funcs/relation.html","url":"/r-apex/docs/R_Funcs/relation.html"},"string":{"title":"String Funcs","description":"String Funcs in R","layout":"guide","icon":"code-file","weight":9,"content":" {$page.description} capitalize Capitalize the string. R.capitalize.run('cat') // Cat match Check regex match. R.match.run('.(a).', 'cat') // (cat, a) pad Pad the string to the length, with given padding. R.pad.run(5, '*', 'cat') // cat padLeft Pad the string to the left to the length, with given padding. R.pad.run(5, '*', 'cat') // **cat padRight Pad the string to the right to the length, with given padding. R.pad.run(5, '*', 'cat') // cat** replace Replace the string with replacement, only for the first occurrence of the matching. R.replace.run('cat', 'dog', 'I love cats') // I love dogs replaceAll Replace the string with replacement, for all occurrences of the matching. R.replaceAll.run('cat', 'dog', 'I love cats') // I love dogs split Split the string into a list. R.split.run(' ', 'a b c') // (a, b, c) test Test for the string matching. R.test.run('.a.', 'cat') // true toLower Convert the string into lowercase. R.toLower.run('ABC') // abc toUpper Convert the string into uppercase. R.toUpper.run('abc') // ABC trim Trim the string. R.trim.run(' abc ') // abc ","srcFilePath":"src/pages/docs/R_Funcs/string.md","id":"string","location":"/docs/R_Funcs/string.html","url":"/r-apex/docs/R_Funcs/string.html"},"utility":{"title":"Utility Funcs","description":"Utility Funcs in R","layout":"guide","icon":"code-file","weight":11,"content":" {$page.description} F A function that always returns false. R.F.run() // false T A function that always returns true. R.T.run() // true compact Remove any null value from the elements. R.compact.run(R.with(1, null, 2)) // (1, 2) debug Print the debug log. R.debug.run(1) // 1 defaultTo Default to a value. R.defaultTo.run(5, null) // 5 doClone Get the clone. R.doClone.run(new Account()) // Account:{} isNil Check if it is null. R.isNil.run(null) // true isNotNil Check if it is not null. R.isNotNil.run(null) // false isNotNull Same as isNotNil. isNull Same as isNil. isNumber Check if it is number. R.isNumber.run(1) // true noop No op function. R.noop.run() // null assert Do System assert R.assert.run(1 == 1, 'should equal'); assertEquals Do System assertEquals R.assertEquals.run(1, 1, 'should equal'); assertNotEquals Do System assertNotEquals R.assertNotEquals.run(1, 2, 'should not equal'); ","srcFilePath":"src/pages/docs/R_Funcs/utility.md","id":"utility","location":"/docs/R_Funcs/utility.html","url":"/r-apex/docs/R_Funcs/utility.html"}},"title":"R.Funcs","description":"Func objects in R","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} R.Funcs Reference Here is the reference of the Funcs from R. You can use these Funcs in the way below: Object val = R.add.run(1, 2); Or Func f = R.add.apply(1); Object val = f.run(2); ","srcFilePath":"src/pages/docs/R_Funcs/index.md","id":"R_Funcs","location":"/docs/R_Funcs/","url":"/r-apex/docs/R_Funcs/","childIds":["conversion","arithmetic","logic","relation","function","comparator","condition","list","string","map","utility","database"]},"Func":{"title":"Func","description":"Documentation of Func Object","layout":"guide","icon":"flash","weight":1,"content":" {$page.description} What is a Func object? A Func object represents a function, namely a block of business logic. Users can create new functions by composing smaller functions, or extend from this class to create any custom functions. How to create a Func object? Here is a sample custom function: class CustomFunc extends Func { public CustomFunc() { super(2); } public override Object exec(Object arg1, Object arg2) { // TODO return null; } } Func f = new CustomFunc(); In the constructor, we may specify the length of the Func by calling super(2), or we can skip this to allow a variadic argument function. There are a few exec methods from Func that we can override to provide our own implementations. Extend exec() if our Func does not accept any argument. Extend exec(Object) if our Func accepts one argument. Extend exec(Object, Object) if our Func accepts two arguments. Extend exec(Object, Object, Object) if our Func accepts three arguments. Extend execMore(List) if our Func accepts more than three arguments. Extend execN(List) if our Func accepts variadic arguments. Here is the guide to help us decide which one is invoked. If Func length is not specified, the exec method is invoked according to the actual number of arguments. If Func length is 0, only the exec() method is invoked. If Func length is 1, only the exec(Object) method is invoked. If Func length is 2, only the exec(Object, Object) method is invoked. If Func length is 3, only the exec(Object, Object, Object) method is invoked. If Func length is more than 3, only the execMore(List) method is invoked. How to invoke a Func object? There are two stages when invoking a Func: a) Applying (optional) Applying is the stage where the Func receives some arguments and stores them for invocation in the future. Here is how we apply a Func: Func f = R.equals.apply(1); If we want to apply more than 3 arguments, we have to use: Func f = SomeFunc.applyN(a, b, c, d, ...); Each applying will in fact create a new Func, which means that the original Func will not get affected. b) Running Running is the stage where the Func uses all the arguments it has collected and produces the final result. Here is how we run a Func: Object result = f.run(1); If we want to run the func with more than 3 arguments, we have to use: Object result = f.runN(a, b, c, d, ...); Suppose Func f takes three arugments, the following cases are equivalent: f.apply(a, b, c).run() === f.run(a, b, c) === f.apply(a).apply(b).apply(c).run() === f.apply(a).apply(b, c).run() === f.apply(a, b).apply(c) Func Package In R.apex, you can bundle your Funcs and export them as a Func Package. Func packages can be used by others without interacting directly with your apex classes. Here is how we define a Func Package: public class CustomPackage extends Func.DefaultPackage { public override void init() { this.export('plus', R.add); } } And you can then require the Func somewhere else. Func plus = Func.require('Custom.plus'); Object result = plus.run(1, 2); The best practice is that you put your package class as a top level class, so that you leave the freedom to users, who can then decide if they are going to use the Func Package, which relies on R.apex. ","srcFilePath":"src/pages/docs/Func/index.md","id":"Func","location":"/docs/Func/","url":"/r-apex/docs/Func/"},"R_Instance":{"children":{"conversion":{"title":"Conversion Methods","description":"Conversion methods of R","layout":"guide","icon":"cloud","weight":2,"content":" {$page.description} Conversion Methods | Type | Method | | ---- | ------ | | Object | toObject | | List&lt;Object&gt; | toList | | Set&lt;String&gt; | toSet | | Map&lt;String, Object&gt; | toMap | | SObject | toSObject | | List&lt;SObject&gt; | toSObjectList | | Map&lt;String, SObject&gt; | toSObjectMap | | Integer | toInteger | | List&lt;Integer&gt; | toIntegerList | | Map&lt;String, Integer&gt; | toIntegerMap | | Long | toLong | | List&lt;Long&gt; | toLongList | | Map&lt;String, Long&gt; | toLongMap | | Double | toDouble | | List&lt;Double&gt; | toDoubleList | | Map&lt;String, Double&gt; | toDoubleMap | | Decimal | toDecimal | | List&lt;Decimal&gt; | toDecimalList | | Map&lt;String, Decimal&gt; | toDecimalMap | | String | toString | | List&lt;String&gt; | toStringList | | Map&lt;String, String&gt; | toStringMap | | Boolean | toBoolean | | List&lt;Boolean&gt; | toBooleanList | | Map&lt;String, Boolean&gt; | toBooleanMap | | Date | toDate | | List&lt;Date&gt; | toDateList | | Map&lt;String, Date&gt; | toDateMap | | Time | toTime | | List&lt;Time&gt; | toTimeList | | Map&lt;String, Time&gt; | toTimeMap | | Datetime | toDatetime | | List&lt;Datetime&gt; | toDatetimeList | | Map&lt;String, Datetime&gt; | toDatetimeMap | | Func | toFunc | | List&lt;Func&gt; | toFuncList | | Map&lt;String, Func&gt; | toFuncMap | | Pair | toPair | | List&lt;Pair&gt; | toPairList | | Map&lt;String, Pair&gt; | toPairMap | Type Checking Methods | Type | Method | | ---- | ------ | | List&lt;Object&gt; | isList | | Set&lt;String&gt; | isSet | | Map&lt;String, Object&gt; | isMap | | String | isString | ","srcFilePath":"src/pages/docs/R_Instance/conversion.md","id":"conversion","location":"/docs/R_Instance/conversion.html","url":"/r-apex/docs/R_Instance/conversion.html"},"creation":{"title":"Creation Methods","description":"Creation methods of R","layout":"guide","icon":"cloud","weight":1,"content":" {$page.description} emptyList Factory function to create instance of R(empty list). R.emptyList().size().debug(); // 0 emptyMap Factory function to create instance of R(empty set). R.emptySet().size().debug(); // 0 emptySet Factory function to create instance of R(empty set). R.emptySet().size().debug(); // 0 emptyString Factory function to create instance of R(empty string). R.emptyString().size().debug(); // 0 of Factory function to create instance of R. R.of('message').size().debug(); // 7 range Factory function to create instance of R(list of decimals in range). R.range(1, 3).debug(); // (1, 2) with Factory function to create instance of R(List). R.with(1).size().debug(); // 1 R.with(1, 2).size().debug(); // 2 R.with(1, 2, 3).size().debug(); // 3 withObj Factory function to create instance of R(Map). R.withObj('name', 'test').size().debug(); // 1 ","srcFilePath":"src/pages/docs/R_Instance/creation.md","id":"creation","location":"/docs/R_Instance/creation.html","url":"/r-apex/docs/R_Instance/creation.html"},"methods":{"title":"Methods","description":"methods of R","layout":"guide","icon":"cloud","weight":3,"content":" {$page.description} adjust Update the element at index with the function. R.with(1, 2, 3).adjust(R.add.apply(1), 1).debug(); // (1, 3, 3) all Check if all elements match the predicate. R.with(1, 2, 3).all(R.equals.apply(1)).debug(); // false append Append the element to the elements. R.with(1, 2, 3).append(4).debug(); // (1, 2, 3, 4) assoc Associate the value to the key. R.withObj('name', 'value').assoc('name', 'newValue').debug(); // {name=newValue} capitalize Return a new string with the first letter in uppercase. R.of('cat').capitalize().debug(); // Cat clamp Return a value that is limited between the min and the max. R.of(4).clamp(1, 3).debug(); // 3 compact Remove null values from the elements. R.with('a', null, 0).compact().debug(); // (a, 0) concat Concatenate the other. R.with(1, 2, 3).concat(R.with(4, 5, 6)).debug(); contains Check if the target is contained. R.with(1, 2, 3).contains(2).debug(); // true containsBy Check if the target is contained by the predicate. R.with(1, 2, 3).containsBy(R.equals, 2).debug(); // true containsKey Check if the key is contained. R.withObj('name', 'test').containsKey('name').debug(); // true countBy Get a result of count mapped by the key. R.with(1, 2, 2).countBy(R.identity).debug(); debug Print debug information. R.with(1, 2).debug(); // (1, 2) defaultTo Get the default value. R.of(null).defaultTo(3).debug(); // 3 difference Do a difference with the other object. R.with(1, 2, 3).difference(R.with(2, 3, 4)).debug(); // (1) dissoc Remove the value mapped by the key. R.withObj('name', 'value').dissoc('name').debug(); // {} doClone Get a clone. R.with(1, 2, 3).doClone().debug(); // (1, 2, 3) doInsert Insert the element at the index. R.with(1, 2, 3).doInsert(1, 'x').debug(); // (1, x, 2, 3) doInsertAll Insert all the elements at the index. R.with(1, 2, 3).doInsertAll(1, R.with('x', 'y')).debug(); // (1, x, y, 2, 3) doJoin Join the elements with the separator. R.with(1, 2, 3).doJoin('-').debug(); // 1-2-3 doMap Map a function over the elements. R.with(1, 2, 3).doMap(R.add.apply(1)).debug(); // (2, 3, 4) doMerge Merge the source. R.withObj('name', 'test').doMerge(R.withObj('name', 'newTest')).debug(); // {name=newTest} doUpdate Update the element at the specified index. R.with(1, 2, 3).doUpdate(1, 3).debug(); // (1, 3, 3) drop Drop the first N elements. R.with(1, 2, 3).drop(2).debug(); // (3) dropRight Drop the first N elements from right. R.with(1, 2, 3).dropRight(2).debug(); // (1) dropRightWhile Drop from right until the predicate is not satisfied. R.with(1, 2, 3).dropRightWhile(R.equals.apply(1)).debug(); // (1, 2, 3) dropWhile Drop until the predicate is not satisfied. R.with(1, 2, 3).dropWhile(R.equals.apply(1)).debug(); // (2, 3) endsWith Check if the elements end with the value. R.of('abc').endsWith('bc').debug(); // true every Check if every element matches the predicate. R.with(1, 2, 3).every(R.equals.apply(1)).debug(); // false evolve Apply the function to the value mapped by the same key and calculate the evolved object. R.withObj('name', 'test').evolve(new Map{ 'name' = R.append.apply('more') }).debug(); // {name=testmore} filter Call the function to filter the elements of instance R. R.with(1, 2, 3).filter(R.equals.apply(2)).debug(); // (2) R.with(new Account(Description = 'desc'), new Account()).filter('Description').debug(); // (Account:{Description=desc}) R.with(new Account(Description = 'desc'), new Account()).filter('Description', 'desc').debug(); // (Account:{Description=desc}) R.with(new Account(Description = 'desc'), new Account()).filter(new Map{ 'Description' = 'desc' }).debug(); // (Account:{Description=desc}) find Find the first element that satisfies the predicate. R.with(1, 2, 3).find(R.equals.apply(2)).debug(); // 2 findIndex Find the index of the first element that matches the predicate. R.with(1, 2, 3).findIndex(R.equals.apply(2)).debug(); // 1 findLast Find the first element that satisfies the predicate from last. R.with(1, 2, 3).findLast(R.equals.apply(2)).debug(); // 2 findLastIndex Find the index of the first element that matches the predicate from last. R.with(1, 2, 3).findLastIndex(R.equals.apply(2)).debug(); // 1 first Get the first element. R.with(1, 2, 3).first().debug(); // 1 flatten Flatten the elements recursively. R.with(1, new List{ 2, new List{ 3 } }, 4).flatten().debug(); // (1, 2, 3, 4) forEach Call the function to each element of instance R. R.with(1, 2, 3).forEach(R.debug); // 1 // 2 // 3 fromPairs Convert from a list of pairs to a map. R.with(new R.Pair('name', 'test')).fromPairs().debug(); // {name=test} groupBy Get a result of count mapped by the key. R.with(1, 2, 2).countBy(R.identity).debug(); head Get the first element. R.with(1, 2, 3).head().debug(); // 1 indexBy Get object indexed by the key. R.with(1, 2, 2).indexBy(R.identity).debug(); indexOf Get the index of the target. R.with(1, 2, 3).indexOf(2).debug(); // 1 init Get the elements except the last. R.with(1, 2, 3).init().debug(); // (1, 2) intersection Do an intersection with the other object. R.with(1, 2, 3).intersection(R.with(2, 3, 4)).debug(); // (2, 3) invert Get an inverted map, values mapped by duplicate keys are put in a list. R.withObj('name', 'test').invert().debug(); invertObj Get an inverted map. R.withObj('name', 'test').invertObj().debug(); // {test=name} isEmpty Check if it is empty. R.with(1, 2, 3).isEmpty().debug(); // false keys Get the keys of the wrapped map. R.withObj('name', 'test').keys().debug(); // {name} last Get the last element. R.with(1, 2, 3).last().debug(); // 3 lastIndexOf Get the index of the target from the last. R.with(1, 2, 3).lastIndexOf(2).debug(); // 1 length Get the length, same as size(). R.with(1, 2, 3).length().debug(); // 3 match Get a list of matched groups after doing a regex match. R.of('abc').match('.(a).').debug(); // (abc, a) none Check if none of the elements matches the predicate. R.with(1, 2, 3).none(R.equals.apply(1)).debug(); // false nth Get the nth element. R.with(1, 2, 3).nth(1).debug(); // 2 omit Omit the values specified by the list of keys. R.of(new Account(FirstName='test', Description='desc')).omit(new List{ 'Description' }).debug(); // {FirstName=test} pad Pad the string to the length. R.of('cat').pad(5, '').debug(); // *cat padLeft Pad the string to the length from the left. R.of('cat').padLeft(5, '').debug(); // *cat padRight Pad the string to the length from the right. R.of('cat').padRight(5, '').debug(); // cat* partition Create a paritioned pair using the predicate. R.with(1, 2, 3).partition(R.equals.apply(1)).debug(); // Pair:[fst=(1), snd=(2, 3)] pick Pick the values specified by the list of keys. R.of(new Account(FirstName='test', Description='desc')).pick(new List{ 'Description' }).debug(); // {Description=desc} pluck Extract the field out of the object to a new list. R.with(new Account(Description='desc')).pluck('Description').debug(); // (desc) prepend Prepend the element to the elements. R.with(1, 2, 3).prepend(4).debug(); // (4, 1, 2, 3) project Project a list of objects using the list of fields. R.with(new Account(Description='desc', FirstName='test')).project(new List{ 'Description' }).debug(); // ({Description=desc}) reduce Reduce over the elements. R.with(1, 2, 3).reduce(R.add, 0).debug(); // 6 reject Reject the elements by checking with the predicate. R.with(new Account(Description = 'desc'), new Account()).reject((Func)R.complement.run(R.has.apply('Description'))).debug(); // (Account:{Description=desc}) R.with(new Account(Description = 'desc'), new Account()).reject('Description').debug(); // (Account:{}) R.with(new Account(Description = 'desc'), new Account()).reject('Description', 'desc').debug(); // (Account:{}) R.with(new Account(Description = 'desc'), new Account()).reject(new Map{ 'Description' = 'desc' }).debug(); // (Account:{}) remove Remove elements starting at the index and specified by the count. R.with(1, 2, 3).remove(1, 3).debug(); // (1) repeat Create a list of elements by repeating the element. R.of('a').repeat(3).debug(); // (a, a, a) replace Replace the string according to the pattern and replacement. R.of('I love cats').replace('cat', 'dog').debug(); // I love dogs replaceAll Replace all the strings according to the pattern and replacement. R.of('I love cats').replaceAll('cat', 'dog').debug(); // I love dogs reverse Reverse the elements. R.with(1, 2, 3).reverse().debug(); // (3, 2, 1) sample Get a random element. R.with(1, 2, 3).sample().debug(); // 3 sampleSize Get a list of random elements. R.with(1, 2, 3).sampleSize(2).debug(); // (3, 1) shuffle Create a shuffled list of elements. R.with(1, 2, 3).shuffle().debug(); // (3, 1, 2) size Get the size, same as length(). R.with(1, 2, 3).size().debug(); // 3 slice Get a slice of the elements. R.with(1, 2, 3).slice(1, 2).debug(); // (2) some Check if some elements match the predicate. R.with(1, 2, 3).some(R.equals.apply(1)).debug(); // true sortBy Sort the elements by the comparator. R.with(new Account(Description='abc'), new Account(Description='def')).sortBy((Func)R.descend.run(R.prop.apply('Description'))).debug(); // (Account:{Description=def}, Account:{Description=abc}) sortDefault Sort the elements by default. R.with(3, 2, 1).sortDefault().debug(); // (1, 2, 3) split Split the string by the separator. R.of('a/b/c').split('/').debug(); // (a, b, c) startsWith Check if the elements start with the value. R.with(1, 2, 3).startsWith(new List{ 1, 2 }).debug(); // true sum Get the sum. R.with(1, 2, 3).sum().debug(); // 6 tail Get the elements except the first. R.with(1, 2, 3).tail().debug(); // (2, 3) take Take the first N elements. R.with(1, 2, 3).take(2).debug(); // (1, 2) takeRight Take the first N elements from right. R.with(1, 2, 3).takeRight(2).debug(); // (2, 3) takeRightWhile Take elements from right until the predicate is not satisfied. R.with(1, 2, 3).takeRightWhile(R.equals.apply(1)).debug(); // () takeWhile Take elements until the predicate is not satisfied. R.with(1, 2, 3).takeWhile(R.equals.apply(1)).debug(); // (1) test Test the string according to the pattern. R.of('cat').test('.b.').debug(); // false toLower Convert the string to lowercase. R.of('Cat').toLower().debug(); // cat toPairs Convert a map to a list of pairs. R.withObj('name', 'test').toPairs().debug(); // (Pair:[fst=name, snd=test]) toUpper Convert the string to uppercase. R.of('cat').toUpper().debug(); // CAT transform Transform the wrapped value using the function. R.with(1, 2, 3).transform(R.size).debug(); // 3 trim Trim the string. R.of(' a ').trim().debug(); // a union Do a union with the other object. R.with(1, 2, 3).union(R.with(2, 3, 4)).debug(); // (1, 2, 3, 4) uniq Return unique elements. R.with(1, 2, 2).uniq().debug(); // (1, 2) unnest Flatten the elements by one level. R.with(1, new List{ 2, 3 }, 4).unnest().debug(); // (1, 2, 3, 4) values Get the values of the wrapped map. R.withObj('name', 'test').values().debug(); // (test) without Same as difference. R.with(1, 2, 3).without(R.with(2, 3, 4)).debug(); // (1) xor Do an xor with the other object. R.with(1, 2, 3).xor(R.with(2, 3, 4)).debug(); // (1, 4) zip Create a zipped list of pairs according to the mList. R.with('a', 'b').zip(new List{ 1, 2 }).debug(); // (Pair:[fst=1, snd=a], Pair:[fst=2, snd=b]) zipObj Create a zipped map according to the mList. R.with('a', 'b').zipObj(new List{ 1, 2 }).debug(); // {1=a, 2=b} ","srcFilePath":"src/pages/docs/R_Instance/methods.md","id":"methods","location":"/docs/R_Instance/methods.html","url":"/r-apex/docs/R_Instance/methods.html"}},"title":"R.Instance","description":"Instance of R","layout":"guide","icon":"cloud","weight":4,"content":" {$page.description} R Instance Method Reference Here is the reference of the methods from R instance. You can use them in the way below: R.of(new List{ 'a', 'b', 'c' }) .reverse() .join('-') .toString(); ","srcFilePath":"src/pages/docs/R_Instance/index.md","id":"R_Instance","location":"/docs/R_Instance/","url":"/r-apex/docs/R_Instance/","childIds":["creation","conversion","methods"]}},"childIds":["Func","R_Funcs","R_Instance","search"]},"tutorials":{"title":"Tutorials","description":"The tutorials","url":"/r-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/index.soy","id":"tutorials","location":"/tutorials/","customURL":true,"children":{"getting_started":{"title":"Getting Started","description":"The Getting Started Tutorial","tutorialTitle":"Getting started with R.apex","url":"/r-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/getting_started/index.soy","id":"getting_started","location":"/tutorials/getting_started/","customURL":true,"children":{"step_1":{"title":"Installation","description":"Include Apex files","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":1,"content":" {$page.title} Include Func.cls, R.cls, and RTest.cls(optional) into your Org, and you are ready to go. ","srcFilePath":"src/pages/tutorials/getting_started/step_1.md","id":"step_1","location":"/tutorials/getting_started/step_1.html","url":"/r-apex/tutorials/getting_started/step_1.html"},"step_2":{"title":"HelloWorld Function","description":"Create a simple HelloWorld function","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":2,"content":" {$page.title} Apex does not support first class functions, and we have NO WAY to get around it. However, we can create an invocable object camouflaged as a function, and it is referred to as a Func. Or more precisely, it is an instance of class Func. In R.apex, we roughly refer to instances of Func when we mention functions, to make things clear. Here is how we create a function that returns Hello World. public class HelloWorldFunc extends Func { public HelloWorldFunc() { super(0); } public override Object exec() { return 'Hello World'; } } And then we get a function! Func helloworld = new HelloWorldFunc(); Let's invoke this function. String message = (String)helloworld.run(); System.debug(message); // Hello World That's how easy it is to create a function in R.apex. ","srcFilePath":"src/pages/tutorials/getting_started/step_2.md","id":"step_2","location":"/tutorials/getting_started/step_2.html","url":"/r-apex/tutorials/getting_started/step_2.html"},"step_3":{"title":"Function with Arguments","description":"Create a function that takes arguments","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":3,"content":" {$page.title} HelloWorldFunc does not make much sense, though it does a good illustration. Normally we want functions that accept arguments to do complex business logic. Here comes the AddFunc. public class AddFunc extends Func { public AddFunc() { super(2); } public override Object exec(Object arg1, Object arg2) { Integer a = (Integer)arg1; Integer b = (Integer)arg2; return a + b; } } Quite simple, right? In the constructor, we denote that this AddFunc takes two arguments(the length of the function), and correspondingly we override the exec(Object, Object) method from Func to have our custom implementation. Try it. Func add = new AddFunc(); Integer result = (Integer)add.run(1, 2); // 3 To conclude, we set the length of the function in its constructor, and override exec(...) method with correct arguments. For example, if the length of the function is 3, we have exec(Object, Object, Object). Easy, yeah? What about a function with a length of 4? exec(Object, Object, Object, Object)? Nay, when the length goes over 3, we have execMore(List) to override. ","srcFilePath":"src/pages/tutorials/getting_started/step_3.md","id":"step_3","location":"/tutorials/getting_started/step_3.html","url":"/r-apex/tutorials/getting_started/step_3.html"},"step_4":{"title":"Function with Variadic Arguments","description":"Create a function that takes variadic arguments","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":4,"content":" {$page.title} So far so good. What if we need to handle functions that take variadic arguments? Let's extend our AddFunc to allow adding multiple numbers. public class AddFunc extends Func { public AddFunc() { super(-1); } public override Object execN(List args) { Integer sum = 0; for(Object arg : args) { sum += (Integer)arg; } return sum; } } Now this time, we specify the length of the function to be -1, which means that it takes any number of arguments. Also we have our execN(List) overridden to get the sum of all the numbers. By the way, the default length is -1, so if we want a variadic function, we don't even need to call super(-1). In our case, we can simply omit the constructor. ","srcFilePath":"src/pages/tutorials/getting_started/step_4.md","id":"step_4","location":"/tutorials/getting_started/step_4.html","url":"/r-apex/tutorials/getting_started/step_4.html"},"step_5":{"title":"Partial Application","description":"Partial application in R.apex","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":5,"content":" {$page.title} Well, all is good until we find something is missing. In functional programming, we can easily partially apply a function with arguments. Say, we have a function, f: (a, b, c) = a + b + c, and we should fairly easily find out that: var newFa = f(a); var newFb = newFa(b); var newFc = newFb(c); Every time function f is applied part of the arguments it expects, it will save them and return a new function. This is great, as it guarrantees us the following: f(a, b, c) === f(a, b)(c) === f(a)(b, c) === f(a)(b)(c) Beautiful, yeah? We do hope that we can grant this magic to our function. Fortunately, R.apex has always been built with this idea in mind and implementing this is nothing but a piece of cake. See this: Func f1 = add.apply(1); Func f2 = f1.apply(2); Integer result = (Integer)f2.run(); Here, we have formally introduced apply, as a builtin method of Func. And also notice the biggest caveat in R.apex. Apply does not trigger function invocation, while run does. Even if the function has received enough arguments, it will not run until run is explicitly called. Naturally, we have partial application available here. f.run(a, b, c) === f.apply(a, b, c).run() === f.apply(a, b).apply(c).run() === f.apply(a).apply(b, c).run() === f.apply(a).apply(b).apply(c).run() Another thing to notice is that in functional programming, we tend to put the data we are manipulating in the last position in the argument list. For example, R.filter.run(R.isNotNull, myList); // NOT // R.filter.run(myList, R.isNotNull); This is for the convenience of functional composition, which we will cover in the next section. ","srcFilePath":"src/pages/tutorials/getting_started/step_5.md","id":"step_5","location":"/tutorials/getting_started/step_5.html","url":"/r-apex/tutorials/getting_started/step_5.html"},"step_6":{"title":"Function Composition","description":"Function composition in R.apex","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":6,"content":" {$page.title} Hopefully you have got some understanding on how to write a custom function by now. But that's far not enough. Writing functions by extending Func is still somehow bloate with boilerplates and it is kind of tedious. Better ways ahead. The charm of functional programming lies not only in the fact of function currying and partial application, but also in the ability that they can compose. It is composition and decomposition that helps us to build a large application out of small bits and pieces in a functional world. And we adore the power. So it is not hard to understand that functional composition is strongly recommended in R.apex, to write clean and clear codes. Let's take a leap to check it out. Func f = (Func)R.compose.run( R.add.apply(1), R.multiply.apply(2) ); Integer result = (Integer)f.run(2); // 5 Dive into this snippet, and we will make everything clear step by step. First, R.add.apply(1) creates a function f2 that takes one number and adds 1 to it. R.multiply.apply(2) creates a function f1 that takes one number and multiplies 2 to it. Then compose is the magic. It invokes f1 with one argument(i.e, 2) and gets the intermediate result of 4. After that, it invokes f2 with the intermediate result(i.e, 4) and gets the final result of 5. We can see that data flows from f1 to f2, namely, bottom-up, or right-to-left. And this is simply how functional composition works. If you are not quite comfortable with that, you can also try this: Func f = (Func)R.pipe.run( R.multiply.apply(2), R.add.apply(1) ); Integer result = (Integer)f.run(2); // 5 It is actually the same as the previous one, only different in the composition style, namely, top-bottom, or left-to-right. Getting familiar with functional composition is the approach to harness the power of functional programming. It takes time to sharpen the skill, and still there are more tools in functional composition in R.apex waiting to be discovered. ","srcFilePath":"src/pages/tutorials/getting_started/step_6.md","id":"step_6","location":"/tutorials/getting_started/step_6.html","url":"/r-apex/tutorials/getting_started/step_6.html"},"step_7":{"title":"Function Chaining","description":"Function chaining in R.apex","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":7,"content":" {$page.title} It is totally okay if you feel the last section a little too strange, not quite like the code we usually write. We have the alternate option for you: the easy way of function composition through chaining. R.apex adopts the similar chaining style as that of jQuery, Lodash or Promise. If you have experiences of any of these libraries, you will easily pick up R.apex. Here is what function chaining looks like: Integer sum = R.with(1, 2, 3) .doMap(R.inc) .sum() .toInteger(); Pretty familiar, right? In fact, most functions in R.apex are designed to be avaiable both in function composition and function chaining. Check this example: Func sum = (Func)R.pipe.run( R.doMap.apply(R.inc), R.sum, R.toInteger ); Integer result = (Integer)sum.run(R.with(1, 2, 3)); This example is a rewrite of the previous example in functional composition style, and they are equivalent. ","srcFilePath":"src/pages/tutorials/getting_started/step_7.md","id":"step_7","location":"/tutorials/getting_started/step_7.html","url":"/r-apex/tutorials/getting_started/step_7.html"},"step_8":{"title":"Extend R.apex","description":"Extend R.apex","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":8,"content":" {$page.title} It is your personal preference to choose between functional composition and function chaining. And the key takeaway is to use whatever is suitable in your case. It is sad that the discovery of R.apex almost comes to an end. Realizing that the functions provided by R.apex is limited, you have to come up with your functions to tackle all the difficult business logic. The suggestion will be to encapsulate your core business logic in small custom functions and glue them together with the power of R.apex to build your own application. And this is the way you extend R.apex. ","srcFilePath":"src/pages/tutorials/getting_started/step_8.md","id":"step_8","location":"/tutorials/getting_started/step_8.html","url":"/r-apex/tutorials/getting_started/step_8.html"}},"childIds":["step_1","step_2","step_3","step_4","step_5","step_6","step_7","step_8"]}},"childIds":["getting_started"]}},"childIds":["docs","tutorials"]},"basePath":"/r-apex"}